import React, { Component } from 'react'
import { Container, Header, Content, Accordion, Text, H1 } from 'native-base'
const dataArray = [
	{
		title: 'ประพจน์',
		content:
			'ประพจน์ (Proposition)\r\n\nคือ ประโยคที่บอกค่าความจริงได้ โดยที่ค่าความจริงนั้นสามารถจะเป็นจริงหรือเท็จเพียงอย่างใดอย่างหนึ่งเท่านั้น\r\n\nการสร้างประพจน์ (Constructing Propositions)\r\nโดยทั่วไปจะใช้อักษรภาษาอังกฤษแทนประพจน์ อักษรที่นิยมใช้ตัวอย่างเช่น p, q, r, s, … เป็นต้น\rประพจน์ที่มีค่าความจริงเป็นจริง จะถูกแทนค่าด้วย T \rส่วนประพจน์ที่มีค่าความจริงเป็นเท็จ จะถูกแทนค่าด้วย F\r\n\r\n\n ● ↔ ก็ต่อเมื่อ – เป็นจริงเมื่อค่าความจริงของทั้งสองประพจน์เหมือนกัน\r\n\n ● → ถ้า...แล้ว - เป็นเท็จกรณีเดียวเมื่อประพจน์ส่วนหน้าเป็นจริง และประพจน์ส่วนหลังเป็นเท็จ\r\n\n ● ∨ หรือ – เป็นเท็จกรณีเดียวเมื่อทั้งสองประพจน์เป็นเท็จ\r\n\n ● ∧ และ – เป็นจริงกรณีเดียวเมื่อทั้งสองประพจน์เป็นจริง\r\n\n ● ¬ นิเสธ – เปลี่ยนจากจริงเป็นเท็จและเปลี่ยนจากเท็จเป็นจริง\r\n'
	},
	{
		title: 'ตรรกศาสตร์ภาคแสดง',
		content:
			'ตรรกศาสตร์ภาคแสดง\r\n\n คือ ข้อความทางตรรกศาสตร์ ที่สามารถแสดงให้อยู่ในรูป ของฟังก์ชันและเมื่อแทนค่าตัวแปรในฟังก์ชันแล้วสามารถส่งค่ากลับเป็นจริง หรือ เท็จ ได้\r\n\nประพจน์ภาคแสดง (Predicate)\r\nประพจน์ภาคแสดง (predicate) เป็นการปรับปรุงประพจน์แบบเดิม (proposition) ด้วยการ สร้างประพจน์ P(c) จากฟังก์ชันของประพจน์ P(x) โดยที่ P เป็น predicate และ x เป็นตัวแปร (variable) หากแทนค่าตัวแปร x ลงไปด้วยค่าใด ๆ ยกตัวอย่างเช่น c จะทำให้ P(c) กลายเป็น ประพจน์ ซึ่งมีค่าความจริงเป็นจริง หรือ เท็จ ได้\r\n\nนิพจน์ (Expressions)\r\nการนำประพจน์ภาคแสดง (predicates) หลาย ๆ ประพจน์มาผสมกันเพื่อสร้างนิพจน์ (expression) โดย ใช้ตัวเชื่อมตรรกศาสตร์แบบเก่าได้\r\n\nตัวบ่งปริมาณ (Quantifiers)\r\nตัวแบ่งปริมาณมี 2 ชนิดคือ\r\n●  ตัวแบ่งปริมาณเอกภพ (Universal Quantifier) : “สำหรับ…ทุกตัว” แทนด้วยสัญลักษณ์ ∀\r\n●  ตัวแบ่งปริมาณมีอยู่ (Existential Quantifier) : “สำหรับ…บางตัว” แทนด้วยสัญลักษณ์ ∃\r\n\nประโยค ∀ x P(x) มีค่าความจริงเป็นจริง (T) ก็ต่อเมื่อแทนตัวแปร x ใน P(x) ด้วยสมาชิกแต่ละตัวใน เอกภพสัมพัทธ์แล้วได้ประพจน์ที่มีค่าความจริงเป็นจริงทั้งหมด\r\n\nประโยค ∀ x P(x) มีค่าความจริงเป็นเท็จ (F) ก็ต่อเมื่อแทนตัวแปร x ใน P(x) ด้วยสมาชิกอย่างน้อย หนึ่งตัวในเอกภพสัมพัทธ์แล้วได้ประพจน์ที่มีค่าความจริงเป็นเท็จ\r\n'
	},
	{
		title: 'เทคนิคการพิสูจน์',
		content:
			'การอ้างเหตุผลที่สมเหตุสมผล (valid argument)\r\n\n คือ การอ้างจากเหตุทั้งหมดที่เป็นจริง แล้ว ส่งให้ผลเป็นจริง หรือ การแสดงว่าประพจน์ผสมต่อไปนี้เป็น สัจนิรันดร์ \r\n\nกฎการอนุมาน\r\nการอ้างเหตุผลที่พิสูจน์แล้วว่าสมเหตุสมผล สามารถนำไปใช้ในการอ้างเหตุผล ของปัญหาที่ใหญ่ขึ้นได้โดยไม่จำเป็นต้องพิสูจน์อีกสำหรับตรรกศาสตร์เชิงประพจน์นั้นมีกฎการอนุมานที่สำคัญดังนี้\r\n\n1.กฎการแจงผลตามเหตุ (Modus Ponens)\r\n2.กฎการแจงผลค้านเหตุ (Modus Tollens)\r\n3.กฎการแจงผลแบบถ่ายทอด (Transitivity)\r\n4.กฎการแจงผลต่าง (Disjunctive Syllogism)\r\n5.กฎการเพิ่ม (Addition)\r\n6.กฎการทำให้ง่ายขึ้น (Simplification)\r\n7.กฎการเชื่อมกัน (Conjunction)\r\n8.กฎการขจัด (Resolution)\r'
	},
	{
		title: 'เซต',
		content:
			'เซต (Set)\r\n\nสัญลักษณ์ทางคณิตศาสตร์ เพื่อใช้แทนกลุ่มของสิ่งต่าง ๆ ที่เราสนใจ โดยสมาชิกของเซตอาจมีศูนย์หรือมากกว่าศูนย์ชิ้นก็ได้ และลำดับการเขียนสมาชิกของเซตนั้นไม่มีความสำคัญ เซตที่เราสามารถบอกจำนวนสมาชิกได้ เราเรียกว่า เซตจำกัด (finite sets) แต่สำหรับเซตที่มีจำนวน สมาชิกไม่จำกัดนั้น เราเรียกว่า เซตอนันต์\r\n\nเซตของเอกภพสัมพัทธ์ (universal set)\r\nเซตที่กำหนดขอบเขตของสมาชิกในเซตที่เราต้องการจะ ศึกษา สมาชิกที่เป็นไปได้ทั้งหมดในเอกภพสัมพัทธ์ บางครั้งเรียกว่า โดเมน (domain) ซึ่งโดยทั่วไป นิยมใช้ในเรื่องฟังก์ชัน หมายถึง ค่าของตัวแปรที่เป็นไปได้ทั้งหมดที่สามารถป้อนเข้าฟังก์ชันได้ เซต A เป็นสับเซตของเซต B ก็ต่อเมื่อ สมาชิกทุกตัวของ A เป็นสมาชิกของ B\r\n\n●  ยูเนียน (Union) \r\nยูเนียนของเซต A และ B คือเซต A ∪ B ซึ่งประกอบด้วยสมาชิกทั้งหมดที่อยู่ใน A หรือ อยู่ใน B หรือ อยู่ในทั้งสองเซต\r\n\n●  อินเตอร์เซกชัน (Intersection)\r\nอินเตอร์เซกชันของเซต A และ B คือเซต A ∩ B ซึ่งประกอบด้วยสมาชิกทั้งหมดที่อยู่ใน A และ อยู่ ใน B\r\n\n●  คอมพลีเมนต์ (Complement)\r\nคอมพลีเมนต์ของเซต A คือเซต U - A ซึ่งประกอบด้วยสมาชิกทั้งหมดที่อยู่ในเอกภพสัมพัทธ์แต่ไม่ได้ อยู่ใน A เขียนแทนด้วยสัญลักษณ์ Ā (หรือ Ac หรือ A’)\r'
	},
	{
		title: 'ความสัมพันธ์',
		content:
			'ความสัมพันธ์ (relation)\r\n\n คือเซตของคู่อันดับซึ่งเป็นสับเซตของผลคูณคาร์ทีเซียนของเซต A และ เซต B นิยมเขียนแทนด้วยสัญลักษณ์ R (Relation R is a subset of the ordered pairs in AXB) ซึ่งในความหมายข้างต้นจะประกอบด้วย 2 ส่วน คือ\r\n\n ● คู่อันดับ\r\n\n ● ผลคูณคาร์ทีเซียนของเซต A และเซต B (AXB)\r\n\nคู่อันดับ (ordered pairs)\r\nการจับคู่ของสองชิ้นทางคณิตศาสตร์ เช่น คู่อันดับ a, b เขียนแทน ด้วย (a, b) เรียก a ว่าเป็นสมาชิกตัวหน้า และเรียก b ว่าเป็นสมาชิกตัวหลัง\r\n\nผลคูณคาร์ทีเซียนของเซต A และเซต B (Cartesian product)\r\nคือ เซตของคู่อันดับ (a, b) ที่ เป็นไปได้ทั้งหมด โดยที่ a เป็นสมาชิกของเซต A และ b เป็นสมาชิกของเซต B เขียนแทนด้วย AXB ซึ่งเขียนเซตแบบบอกเงื่อนไขได้เป็น AXB = {(a, b) | a ϵ A และ b ϵ B}\r\n\nคุณสมบัติของความสัมพันธ์ (Properties of a Relation)\r\nกำหนดให้ R เป็นความสัมพันธ์บนเซต S (นั้นคือ ความสัมพันธ์จากเซต S ไป S)\r\n\n ● R มีคุณสมบัติสะท้อน (reflexive) ก็ต่อเมื่อ ∀ x ϵ S, (x R x)\r\n ● R มีคุณสมบัติสมมาตร (symmetric) ก็ต่อเมื่อ ∀x,y ϵ S, ถ้า (x R y) แล้ว (y R x)\r\n ● R มีคุณสมบัติถ่ายทอด (transitive) ก็ต่อเมื่อ ∀x,y,z ϵ S, ถ้า (x R y) และ (y R z) แล้ว (x R z)\r '
	},
	{
		title: 'ฟังก์ชัน',
		content:
			'ฟังก์ชัน\n\nความสัมพันธ์ชนิดหนึ่งซึ่งหากกำหนดให้ f เป็นสับเซตของ AxB แล้ว จะได้ f เป็นฟังก์ชันจาก A ไป B ก็ต่อเมื่อ สมาชิก x ใน A ตัวที่เท่ากัน ต้องมีสมาชิก y ใน B ที่ไม่ แตกต่างกัน (นั้นคือ x ใด ๆ จับคู่กับ y ได้เพียงตัวเดียวเท่านั้น)\r\n\nอิมเมจ พรีอิมเมจ และ เรนจ์ (Image, Pre-image and Range)\r\nถ้า (x, y) ϵ f หรือ y = f (x) เราเรียก y ว่า อิมเมจ (image) ของ x และเรียก x ว่า พรีอิมเมจ (pre-image) ของ y\r\nเราเรียกเซตของอิมเมจ (image) ภายใต้ f ทั้งหมดของสมาชิกของเซต A ว่า เรนจ์ (range) ของ f สามารถเขียนแทนด้วย f(A)\r\n\n ● ฟังก์ชันหนึ่งต่อหนึ่ง (One-to-one Function)\r\n\n ● ฟังก์ชันที่สมาชิกตัวหลังจับคู่กับสมาชิกตัวหน้าเพียง 1 ตัวเท่านั้น เรียกอีกอย่างหนึ่งว่า injective function\r\n\n ● ฟังก์ชันทั่วถึง (Onto Function)\r\n\n ● ฟังก์ชันที่สมาชิกตัวหน้าจับคู่กับสมาชิกตัวหลังครบทุกตัว เรียกอีกอย่างหนึ่งว่า surjective function\r\n\n ● ฟังก์ชันหนึ่งต่อหนึ่งทั่วถึง (One-to-one Correspondence)\r\n\n ● ฟังก์ชันที่สมาชิกตัวหลังจับคู่กับสมาชิกตัวหน้าเพียง 1 ตัวเท่านั้น โดยที่สมาชิกตัวหน้าต้องจับคู่กับ สมาชิกตัวหลังครบทุกตัว เรียกอีกอย่างหนึ่งว่า bijective function\r '
	},
	{
		title: 'พื้นฐานการนับ',
		content:
			'พื้นฐานการนับ (basics of counting) เกี่ยวข้องกับกฎในการนับจำนวนของวิธีการหรือรูปแบบ ของสิ่งของหรืองานต่าง ๆ ที่เป็นไปได้ภายใต้เงื่อนไขที่โจทย์กำหนด โดยมีกฎ 5 ข้อ คือ\n\n●  กฏการคูณ\n●  กฏการบวก\n●  กฏการบวกและการคูณ\n●  กฏการลบ\n●  กฏการหาร'
	},
	{
		title: 'วีธีอุปนัยเชิงคณิตศาสตร์',
		content:
			'วิธีอุปนัยเชิงคณิตศาสตร์ (mathematical induction) เป็นวิธีที่ใช้ในการพิสูจน์ว่าฟังก์ชันของ ประพจน์ใด ๆ หรือข้อความทางคณิตศาสตร์ใด ๆ เป็นจริงเสมอ สำหรับเลขจำนวนนับทุกจำนวนที่ กำหนดให้มา\n\nกำหนดให้ S(n) แทนข้อความหนึ่งทางคณิตศาสตร์ วิธีอุปนัยเชิงคณิตศาสตร์เป็นวิธีการพิสูจน์เพื่อ แสดงให้เห็นว่าข้อความนี้เป็นจริง สำหรับทุก ๆ จำนวนเต็ม n ≥ n0 โดยที่ n ϵ N และ N เป็นเซต ของจำนวนนับ {0,1,2,3….} สำหรับขั้นตอนในการพิสูจน์มีดังนี้\n\n1.ขั้นตอนพื้นฐาน (Basis Step) : แสดงว่า S(n0) เป็นจริง (ส่วนใหญ่ n0 = 0 หรือ n0 = 1 ดังนั้นในขั้นตอนนี้ให้แสดงว่า S(0) หรือ S(1) เป็นจริง)\n\n 2.ขั้นตอนอุปนัย (Inductive Step) : แสดงว่าถ้า S(n) เป็นจริงแล้ว S(n+1) เป็นจริง สำหรับ ทุก ๆ จำนวนเต็ม n ≥ n0 เขียนในรูปสัญลักษณ์ได้ว่า S(n) → S(n+1) for all n ≥ n0 \n\n3.ขั้นตอนสรุป (Conclusion) : สรุปว่า S(n) ต้องเป็นจริง สำหรับทุก ๆ จำวนเต็ม n ≥ n0'
	},
	{
		title: 'การเรียกตัวเอง',
		content:
			'การเรียกตัวเอง ในการเขียนนิยามการเรียกตัวเอง (recursive defnitions) ต้องมีการระบุ 2 ส่วน ดังต่อไปนี้\n\n1.ส่วนพื้นฐาน (Basis) เป็นส่วนที่มีการนิยามค่าต่ำสุดที่โปรแกรมยังท างานได้อยู่ ในส่วนนี้จะ กลายเป็นเงื่อนไขในการหยุดท างานของโปรแกรมแบบเรียกตัวเอง\n\n 2.ส่วนอุปนัย (Induction) เป็นส่วนที่มีการเรียกตัวเองเกิดขึ้นซ้ำ ๆ ในส่วนนี้วิธีของการแก้ปัญหา ใหญ่จะถูกนิยามโดยใช้วิธีของการแก้ปัญหาย่อย'
	},
	{
		title: 'การวิเคราะห์บิ๊กโอ',
		content:
			'การคำนวณเวลาในการประมวลผลของโปรแกรมที่เป็นมาตรฐาน กลางจึงจะไม่คำนวณเป็นหน่วยวินาที แต่จะคำนวณโดยใช้ฟังก์ชันที่แปรผันกับจำนวนข้อมูล n ที่ ป้อนเข้าไป\n\nกำหนดให้โปรแกรมใด ๆ ใช้เวลาในการประมวลผล T(n)\nT(n) = ค่าคงที่ x n\nT(n) = c*n\nโดยที่ c เป็นค่าคงที่ และ n เป็นจำนวนข้อมูลที่โปรแกรมต้องประมวลผล\n\nT(n) เป็นฟังก์ชันแสดงประสิทธิภาพเชิงเวลา คือ ฟังก์ชันที่แสดงให้เห็นถึงเวลามากสุดที่โปรแกรมใช้ ในการประมวลผลหลังจากป้อนจำนวนข้อมูล n ข้อมูลเข้าไป เป็นสัญลักษณ์ที่ใช้เพื่อแสดงลักษณะ การเติบโตของฟังก์ชันที่แปรผันตาม n ซึ่งเป็นอินพุตของฟังก์ชัน บางฟังก์ชันก็เติบโตเร็วมาก บาง ฟังก์ชันก็เติบโตช้า ฟังก์ชันแสดงประสิทธิภาพเชิงเวลาที่ดีคือฟังก์ชันที่เมื่อน าเข้าข้อมูลจำนวนมาก แล้วฟังก์ชันมีการเติบโตช้า'
	},
	{
		title: 'ทฤษฎีกราฟ',
		content:
			'กราฟไม่ระบุทิศทาง (Undirected Graph)\nพิจารณาปัญหาต่อไปนี้ เจ้าหน้าที่คนหนึ่งอาศัยอยู่ที่เมือง A ต้องการส ารวจเส้นทางไปยังเมืองต่าง ๆ ทุกเส้นทาง โดยมีเงื่อนไขดังนี้\n\n1.ผู้เดินทางต้องผ่านเมืองต่าง ๆ โดยใช้เส้นทางที่ไม่ซ้ ากันและต้องผ่านทุกเส้นทาง\n\n2.ผู้เดินทางต้องเริ่มที่เมือง A และจบที่เมือง A \n\n'
	},
	{
		title: 'ออโตมาตา',
		content:
			'ออโตมาตา (automata) หรือ เครื่องจักรกลอัตโนมัติ \n\nเป็นโมเดลจำลองทางคณิตศาสตร์ของระบบสถานะจำกัด (fnite state sytems) ที่มีจำนวนสถานะชัดเจนอยู่ในโมเดลนั้น ๆ เราสามารถเขียนโมเดลออโตมาตาในลักษณะเดียวกันกับกราฟระบุทิศทาง โดยที่มีเส้นเชื่อมแสดงการเปลี่ยนแปลงสถานะ และจุดยอดแสดงสถานะต่างๆ ในโมเดล ออโตมาตาทำงานด้วยการรับอินพุตเพื่อเปลี่ยนแปลงสถานะ จากสถานะหนึ่งไปยังอีกสถานะหนึ่ง โดยที่การเปลี่ยนแปลงสถานะนั้นจะตัดสินใจจากว่าขณะปัจจุบันอยู่ที่สถานะใดและอินพุตที่รับเข้ามาในขณะนั้นเป็นอย่างไร\n\nออโตมาตา รูปพหูพจน์ ออโตมาตา (automata), รูปเอกพจน์ ออโตมาตอน (automaton)'
	}
]
export default class ContentScreen extends Component {
	static navigationOptions = {
		title: 'Content'
	}
	render() {
		const { navigate } = this.props.navigation
		return (
			<Container>
				<Header>
					<H1>Discrete Math</H1>
				</Header>
				<Content padder>
					<Accordion dataArray={dataArray} icon="add" expandedIcon="remove" />
				</Content>
			</Container>
		)
	}
}
